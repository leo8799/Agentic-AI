import datetime
import platform
import argparse
import time
import json
import re
import os
import shutil
import logging

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains

from prompts import SYSTEM_PROMPT, SYSTEM_PROMPT_TEXT_ONLY, SYSTEM_PREVIOUS_STEP, ERROR_GROUNDING_AGENT_PROMPT
from google import genai
from google.genai import types
from google.genai.chats import Chat
from rag_implementation import GeminiChromaRAG
from utils import get_web_element_rect, encode_image, extract_information, print_message,\
    get_webarena_accessibility_tree, get_pdf_retrieval_ans_from_assistant, get_pdf_retrieval_ans_from_rag, clip_message_and_obs, clip_message_and_obs_text_only

from instrustion_manual_generator import InstructionManualGenerator


def setup_logger(folder_path):
    log_file_path = os.path.join(folder_path, 'agent.log')

    logger = logging.getLogger()
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
        handler.close()

    handler = logging.FileHandler(log_file_path, encoding='utf-8')
    formatter = logging.Formatter('%(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)


def driver_config(args):
    options = webdriver.ChromeOptions()
    
    download_dir = os.path.abspath(args.download_dir)

    if args.save_accessibility_tree:
        args.force_device_scale = True

    if args.force_device_scale:
        options.add_argument("--force-device-scale-factor=1")
    if args.headless:
        options.add_argument("--headless")
        options.add_argument(
            "--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36"
        )
    
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-gpu")
    options.add_argument("--disable-extensions")
    options.add_argument("--disable-background-timer-throttling")
    options.add_argument("--disable-backgrounding-occluded-windows")
    options.add_argument("--disable-renderer-backgrounding")
    options.add_argument("--disable-features=TranslateUI")
    options.add_argument("--disable-ipc-flooding-protection")
    options.add_argument("--remote-debugging-port=9222")
    
    import tempfile
    import uuid
    temp_dir = tempfile.gettempdir()
    user_data_dir = os.path.join(temp_dir, f"chrome_user_data_{uuid.uuid4()}")
    options.add_argument(f"--user-data-dir={user_data_dir}")
    
    options.add_experimental_option(
        "prefs", {
            "download.default_directory": download_dir,
            "plugins.always_open_pdf_externally": True
        }
    )
    options.add_argument("disable-blink-features=AutomationControlled")
    return options


def format_msg(it, init_msg, pdf_obs, warn_obs, web_img_b64, web_text, prev_step_action=""):
    # 修改dict格式，從content改爲parts
    if it == 1:
        init_msg += f"{prev_step_action}\nI've provided the tag name of each element and the text it contains (if text exists). Note that <textarea> or <input> may be textbox, but not exactly. Please focus more on the screenshot and then refer to the textual information.\n{web_text}"
        
        init_msg_format = {
            'role': 'user',
            'parts': [
                {'text': init_msg},
            ]
        }
        
        init_msg_format['parts'].append({"inline_data": {"mime_type": "image/png", "data": f"{web_img_b64}"}})
        return init_msg_format
    else:
        if not pdf_obs:
            curr_msg = {
                'role': 'user',
                'parts': [
                    {'text': f"{prev_step_action}\nObservation:{warn_obs} please analyze the attached screenshot and give the Thought and Action. I've provided the tag name of each element and the text it contains (if text exists). Note that <textarea> or <input> may be textbox, but not exactly. Please focus more on the screenshot and then refer to the textual information.\n{web_text}"},
                    {'inline_data': {"mime_type": "image/png", "data": "{}".format(web_img_b64)}}
                ]
            }
        else:
            curr_msg = {
                'role': 'user',
                'parts': [
                    {'text': f"{prev_step_action}\nObservation: {pdf_obs} Please analyze the response given by Assistant, then consider whether to continue iterating or not. The screenshot of the current page is also attached, give the Thought and Action. I've provided the tag name of each element and the text it contains (if text exists). Note that <textarea> or <input> may be textbox, but not exactly. Please focus more on the screenshot and then refer to the textual information.\n{web_text}"},
                    {'inline_data': {"mime_type": "image/png", "data": "{}".format(web_img_b64)}}
                ]
            }
        return curr_msg


def format_msg_text_only(it, init_msg, pdf_obs, warn_obs, ac_tree, prev_step_action=""):
    if it == 1:
        init_msg_format = {
            'role': 'user',
            'parts': init_msg + '\n' + ac_tree
        }
        return init_msg_format
    else:
        if not pdf_obs:
            curr_msg = {
                'role': 'user',
                'parts': f"{prev_step_action}\nObservation:{warn_obs} please analyze the accessibility tree and give the Thought and Action.\n{ac_tree}"
            }
        else:
            curr_msg = {
                'role': 'user',
                'parts': f"{prev_step_action}\nObservation: {pdf_obs} Please analyze the response given by Assistant, then consider whether to continue iterating or not. The accessibility tree of the current page is also given, give the Thought and Action.\n{ac_tree}"
            }
        return curr_msg

def call_gemini_api(args, gemini_client: genai.Client, messages, system_instruction):
    retry_times = 0
    while True:
        try:
            if not args.text_only:
                logging.info('Calling gemini API...')
                google_response = gemini_client.models.generate_content(
                    model=args.api_model,
                    contents=messages,
                    config=types.GenerateContentConfig(
                        system_instruction=system_instruction,
                        max_output_tokens=10000,
                        temperature=args.temperature,
                        seed=args.seed
                    )
                )
            else:
                logging.info('Calling gemini API...')
                google_response = gemini_client.models.generate_content(
                    model=args.api_model,
                    contents=messages,
                    config=types.GenerateContentConfig(
                        system_instruction=system_instruction,
                        max_output_tokens=10000,
                        temperature=args.temperature,
                        seed=args.seed
                    )
                )
            if not google_response.candidates:
                print("⚠️ Gemini 回傳為空！可能觸發了安全限制、格式錯誤，或 prompt 不清楚。")
                for message in len(messages):
                    print(message["parts"][0]["text"])
                print(google_response)
                # 可以儲存該 prompt 做進一步分析

                
            prompt_tokens = getattr(google_response.usage_metadata, "prompt_token_count", 0) or 0
            completion_tokens = getattr(google_response.usage_metadata, "candidates_token_count", 0) or 0
            
            logging.info("Prompt Tokens: {}; Completion Tokens: {}".format(prompt_tokens, completion_tokens))
            gemini_call_error = False
            return prompt_tokens, completion_tokens, gemini_call_error, google_response
        except Exception as e:
            logging.info("Error occurred, retrying. Error type: {}".format(type(e).__name__))
            
            if type(e).__name__ == 'GoogleAPICallError' or type(e).__name__ == "RetryError":
                logging.warning(f'Google API Error occurred, retrying... Error type: {type(e).__name__}')
                time.sleep(10)  # 等待 10 秒後重試
            elif type(e).__name__ == 'InvalidArgument':
                logging.error(f'Invalid request to Gemini API: {str(e)}')
                return None, None, True, None  # 返回錯誤狀態
            else:
                logging.error(f'Unexpected error: {type(e).__name__}: {str(e)}')
                logging.info(messages[-1])
                for idx, m in enumerate(messages):
                    parts = m.get("parts")
                    if not isinstance(parts, list):
                        print(f"❌ Message[{idx}] has invalid parts type: {type(parts)}")
                        print("Message content:", m)

                return None, None, True, None  # 返回錯誤狀態
        
        retry_times += 1
        if retry_times == 10:
            logging.error('Retrying too many times')
            return None, None, True, None
                

def call_gpt4v_api(args, openai_client, messages):
    retry_times = 0
    while True:
        try:
            if not args.text_only:
                logging.info('Calling gpt4v API...')
                openai_response = openai_client.chat.completions.create(
                    model=args.api_model, messages=messages, max_tokens=1000, seed=args.seed
                )
            else:
                logging.info('Calling gpt4 API...')
                openai_response = openai_client.chat.completions.create(
                    model=args.api_model, messages=messages, max_tokens=1000, seed=args.seed, timeout=30
                )

            prompt_tokens = openai_response.usage.prompt_tokens
            completion_tokens = openai_response.usage.completion_tokens

            logging.info(f'Prompt Tokens: {prompt_tokens}; Completion Tokens: {completion_tokens}')

            gpt_call_error = False
            return prompt_tokens, completion_tokens, gpt_call_error, openai_response

        except Exception as e:
            logging.info(f'Error occurred, retrying. Error type: {type(e).__name__}')

            if type(e).__name__ == 'RateLimitError':
                time.sleep(10)

            elif type(e).__name__ == 'APIError':
                time.sleep(15)

            elif type(e).__name__ == 'InvalidRequestError':
                gpt_call_error = True
                return None, None, gpt_call_error, None

            else:
                gpt_call_error = True
                return None, None, gpt_call_error, None

        retry_times += 1
        if retry_times == 10:
            logging.info('Retrying too many times')
            return None, None, True, None


def exec_action_click(info, web_ele, driver_task):
    driver_task.execute_script("arguments[0].setAttribute('target', '_self')", web_ele)
    web_ele.click()
    time.sleep(3)


def exec_action_type(info, web_ele, driver_task):
    warn_obs = ""
    type_content = info['parts']

    ele_tag_name = web_ele.tag_name.lower()
    ele_type = web_ele.get_attribute("type")
    # outer_html = web_ele.get_attribute("outerHTML")
    if (ele_tag_name != 'input' and ele_tag_name != 'textarea') or (ele_tag_name == 'input' and ele_type not in ['text', 'search', 'password', 'email', 'tel']):
        warn_obs = f"note: The web element you're trying to type may not be a textbox, and its tag name is <{web_ele.tag_name}>, type is {ele_type}."
    try:
        # Not always work to delete
        web_ele.clear()
        # Another way to delete
        if platform.system() == 'Darwin':
            web_ele.send_keys(Keys.COMMAND + "a")
        else:
            web_ele.send_keys(Keys.CONTROL + "a")
        web_ele.send_keys(" ")
        web_ele.send_keys(Keys.BACKSPACE)
    except:
        pass

    actions = ActionChains(driver_task)
    actions.click(web_ele).perform()
    actions.pause(1)

    try:
        driver_task.execute_script("""window.onkeydown = function(e) {if(e.keyCode == 32 && e.target.type != 'text' && e.target.type != 'textarea' && e.target.type != 'search') {e.preventDefault();}};""")
    except:
        pass

    actions.send_keys(type_content)
    actions.pause(2)

    actions.send_keys(Keys.ENTER)
    actions.perform()
    time.sleep(10)
    return warn_obs


def exec_action_scroll(info, web_eles, driver_task, args, obs_info):
    scroll_ele_number = info['number']
    scroll_content = info['parts']
    if scroll_ele_number == "WINDOW":
        if scroll_content == 'down':
            driver_task.execute_script(f"window.scrollBy(0, {args.window_height*2//3});")
        else:
            driver_task.execute_script(f"window.scrollBy(0, {-args.window_height*2//3});")
    else:
        if not args.text_only:
            scroll_ele_number = int(scroll_ele_number)
            web_ele = web_eles[scroll_ele_number]
        else:
            element_box = obs_info[scroll_ele_number]['union_bound']
            element_box_center = (element_box[0] + element_box[2] // 2, element_box[1] + element_box[3] // 2)
            web_ele = driver_task.execute_script("return document.elementFromPoint(arguments[0], arguments[1]);", element_box_center[0], element_box_center[1])
        actions = ActionChains(driver_task)
        driver_task.execute_script("arguments[0].focus();", web_ele)
        if scroll_content == 'down':
            actions.key_down(Keys.ALT).send_keys(Keys.ARROW_DOWN).key_up(Keys.ALT).perform()
        else:
            actions.key_down(Keys.ALT).send_keys(Keys.ARROW_UP).key_up(Keys.ALT).perform()
    time.sleep(3)
    
def exec_action_select(info, web_ele, driver_task):
    """
    選擇 <select> 元素中的某個 <option>。
    
    參數：
    - info: 包含選擇內容的字典，例如 {'parts': '選項 B'} 或 {'parts': 'value2'}
    - web_ele: Selenium 的 WebElement 對象，對應 <select> 標籤
    - driver_task: Selenium WebDriver 物件
    """
    warn_obs = ""
    select_value = info['parts']
    
    # 確保 web_ele 是 <select> 元素
    ele_tag_name = web_ele.tag_name.lower()
    if ele_tag_name != "select":
        warn_obs = f"note: The web element you're trying to select may not be a dropdown, and its tag name is <{ele_tag_name}>."
        return warn_obs

    try:
        # 方式 1：使用 Select 類來選擇 option
        from selenium.webdriver.support.ui import Select
        select_element = Select(web_ele)

        # 優先匹配 option 的 value，若找不到則匹配 text
        found = False
        for option in select_element.options:
            if option.get_attribute("value") == select_value:
                select_element.select_by_value(select_value)
                found = True
                break
            elif option.text.strip() == select_value:
                select_element.select_by_visible_text(select_value)
                found = True
                break

        if not found:
            warn_obs = f"note: Could not find an <option> with value or text '{select_value}'."

    except Exception as e:
        warn_obs = f"error: Failed to select option due to {str(e)}."

    # 觸發 change 事件，確保網頁能夠正確響應
    try:
        driver_task.execute_script("arguments[0].dispatchEvent(new Event('change', { bubbles: true }));", web_ele)
    except:
        pass

    time.sleep(3)
    return warn_obs

def exec_action_generatetext(args, client, info, rag_system):
    """
    使用 RAG 系統生成文本摘要
    
    參數：
    - args: 命令行參數物件，包含模型配置等信息
    - client: Gemini API 客戶端
    - info: 包含生成文本所需信息的字典，例如 {'parts': '任務描述文本'}
    - rag_system: RAG 系統實例，用於檢索和生成摘要
    
    返回：
    - str: 生成的摘要文本或錯誤信息
    """
    try:
        # 從 info 中獲取任務描述
        task_description = info.get('parts', '')
        if not task_description:
            return "錯誤：未提供任務描述"
            
        # 使用 RAG 系統生成摘要
        summary = get_pdf_retrieval_ans_from_rag(
            args=args,
            client=client,
            task=task_description,
            rag_system=rag_system
        )
        
        return summary
        
    except Exception as e:
        error_msg = f"生成摘要時發生錯誤：{str(e)}"
        logging.error(error_msg)
        return error_msg

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--test_file', type=str, default='data/test.json')
    parser.add_argument('--max_iter', type=int, default=5)
    parser.add_argument('--trajectory', action='store_true')
    parser.add_argument('--rag', action='store_true')
    parser.add_argument("--EGA", action='store_true')
    parser.add_argument("--error_max_reflection_iter", type=int, default=1, help='Number of reflection restarts allowed when exceeding max_iter')
    parser.add_argument("--api_key", default="key", type=str, help="YOUR_OPENAI_API_KEY")
    parser.add_argument("--api_model", default="gemini-2.5-pro-preview-03-25", type=str, help="api model name")
    parser.add_argument("--output_dir", type=str, default='results')
    parser.add_argument("--seed", type=int, default=None)
    parser.add_argument("--max_attached_imgs", type=int, default=1)
    parser.add_argument("--temperature", type=float, default=1.0)
    parser.add_argument("--download_dir", type=str, default="downloads")
    parser.add_argument("--text_only", action='store_true')
    # for web browser
    parser.add_argument("--headless", action='store_true', help='The window of selenium')
    parser.add_argument("--save_accessibility_tree", action='store_true')
    parser.add_argument("--force_device_scale", action='store_true')
    parser.add_argument("--window_width", type=int, default=1920)
    parser.add_argument("--window_height", type=int, default=1068)  # for headless mode, there is no address bar
    parser.add_argument("--fix_box_color", action='store_true')
    parser.add_argument("--start_maximized", action='store_true')

    args = parser.parse_args()

    # OpenAI client
    # client = OpenAI(api_key=args.api_key)
    client = genai.Client(api_key=args.api_key)
    # 多輪對話模式
    # chat = client.chats.create(model=args.api_model, config=types.GenerateContentConfig(system_instruction=SYSTEM_PROMPT, max_output_tokens=1000, seed=args.seed))

    # 初始化 RAG 系統
    rag_system = GeminiChromaRAG(api_key=args.api_key)
    
    options = driver_config(args)

    # Save Result file
    current_time = time.strftime("%Y%m%d_%H_%M_%S", time.localtime())
    result_dir = os.path.join(args.output_dir, current_time)
    os.makedirs(result_dir, exist_ok=True)

    # Load tasks
    tasks = []
    with open(args.test_file, 'r', encoding='utf-8') as f:
        for line in f:
            tasks.append(json.loads(line))
            
    rag_system.add_pdf('data/arXiv.pdf', chunk_size=1000, chunk_overlap=200) 


    for task_id in range(len(tasks)):
        task = tasks[task_id]
        task_dir = os.path.join(result_dir, 'task{}'.format(task["id"]))
        os.makedirs(task_dir, exist_ok=True)
        setup_logger(task_dir)
        logging.info(f'########## TASK{task["id"]} ##########')

        driver_task = webdriver.Chrome(options=options)
        if args.start_maximized: driver_task.maximize_window()
        
        # About window size, 765 tokens
        # You can resize to height = 512 by yourself (255 tokens, Maybe bad performance)
        else: driver_task.set_window_size(args.window_width, args.window_height)

        
          # larger height may contain more web information
        driver_task.get(task['web'])
        try:
            '''
            可能的用途
            激活頁面：某些網頁需要使用者點擊頁面後才能輸入資料或進行其他互動，如啟用鍵盤輸入。
            關閉彈窗：某些網站會在載入時顯示彈窗，點擊空白處可能會自動關閉它。
            觸發 JavaScript 事件：有些網站的 JavaScript 可能要求使用者進行點擊後才會載入完整內容。
            '''
            
            driver_task.find_element(By.TAG_NAME, 'body').click()
        except:
            pass
        # sometimes enter SPACE, the page will sroll down
        # 在網頁上，按下空白鍵通常會讓頁面向下滾動，這行代碼的作用就是 阻止空白鍵滾動頁面，但不影響在輸入框內輸入空格。
        driver_task.execute_script("""window.onkeydown = function(e) {if(e.keyCode == 32 && e.target.type != 'text' && e.target.type != 'textarea') {e.preventDefault();}};""")
        time.sleep(5)

        # We only deal with PDF file
        for filename in os.listdir(args.download_dir):
            file_path = os.path.join(args.download_dir, filename)
            if os.path.isfile(file_path):
                os.remove(file_path)

        download_files = []  # sorted(os.listdir(args.download_dir))

        fail_obs = ""  # When error execute the action
        pdf_obs = ""  # When download PDF file
        warn_obs = ""  # Type warning
        
        # 爲了多智能體之間的協作，添加了Errors、Explanation這兩個pattern
        pattern = r'Thought:|Action:|Observation:|Errors:|Explanation:'

        # messages = [{'role': 'system', 'parts': SYSTEM_PROMPT}]
        messages = []
        # message = {{'role': 'system', 'parts': SYSTEM_PROMPT}}
        obs_prompt = "Observation: please analyze the attached screenshot and give the Thought and Action. "
        if args.text_only:
            messages = []
            # messages = [{'role': 'system', 'parts': SYSTEM_PROMPT_TEXT_ONLY}]
            # message = {'role': 'system', 'parts': SYSTEM_PROMPT}
            obs_prompt = "Observation: please analyze the accessibility tree and give the Thought and Action."
        
           
        rag_result = rag_system.search(task['ques'], n_results=3)
        
        # 使用 InstructionManualGenerator 處理 RAG 結果
        manual_generator = InstructionManualGenerator(
            api_key=args.api_key,
            task_goal=task['ques'],
            results=rag_result,
            logger=logging.getLogger(__name__)
        )
        
        try:
            manual = manual_generator.generate_instruction_manual()
            logging.info(f"Generated instruction manual:\n{manual}")
        except Exception as e:
            logging.warning(f"Failed to generate instruction manual: {e}")
            # 如果生成失敗，回退到原始 RAG 結果
            manual = str(rag_result)
            logging.info(f"Using fallback RAG result:\n{manual}")

        logging.info(f"manual:\n {manual}")

        today_date = datetime.date.today().strftime('%Y-%m-%d')
        init_msg = f"""Today is {today_date}. Now given a task: {task['ques']}  Please interact with https://www.example.com and get the answer. \n"""
        init_msg = init_msg.replace('https://www.example.com', task['web'])
        init_msg += """Before taking action, carefully analyze the contents in [Manuals and QA pairs] below.
Determine whether [Manuals and QA pairs] contain relevant procedures, constraints, or guidelines that should be followed for this task.
If so, follow their guidance accordingly. If not, proceed with a logical and complete approach.\n"""

        init_msg += f"""[Key Guidelines You MUST follow]
Before taking any action, analyze the provided [Manuals and QA pairs] as a whole to determine if they contain useful procedures, constraints, or guidelines relevant to this task.
 - If [Manuals and QA pairs] provide comprehensive guidance, strictly follow their instructions in an ordered and structured manner.
 - If [Manuals and QA pairs] contain partial but useful information, integrate it into your approach while filling in the gaps logically.
 - If [Manuals and QA pairs] are entirely irrelevant or insufficient, proceed with the best available method while ensuring completeness.\n
[Manuals and QA pairs]
{manual}\n"""
        init_msg = init_msg + obs_prompt

        it = 0
        accumulate_prompt_token = 0
        accumulate_completion_token = 0
        
        """=========================================初始化Error Grounding Agent的各個參數============================================="""
        activate_EGA = args.EGA
        error_exist = False
        EGA_explanation = ""
        bot_thought = ""
        chosen_action = ""
        
        # Reflection: Trajectory
        current_history = ""
        
        
        print(f"Trajectory: {args.trajectory}")
        print(f"EGA: {activate_EGA}")
        """=========================================初始化Error Grounding Agent的各個參數============================================="""
        

        while it < args.max_iter:
            logging.info(f'Iter: {it}')
            it += 1
            if not fail_obs:
                try:
                    if not args.text_only:
                        # 獲取element區域
                        rects, web_eles, web_eles_text = get_web_element_rect(driver_task, fix_color=args.fix_box_color)
                        # print("rects:", rects)
                        # print("web_eles:", web_eles)
                        # print("web_eles_text:", web_eles_text)
                    else:
                        accessibility_tree_path = os.path.join(task_dir, 'accessibility_tree{}'.format(it))
                        ac_tree, obs_info = get_webarena_accessibility_tree(driver_task, accessibility_tree_path)

                except Exception as e:
                    if not args.text_only:
                        logging.error('Driver error when adding set-of-mark.')
                    else:
                        logging.error('Driver error when obtaining accessibility tree.')
                    logging.error(e)
                    break

                img_path = os.path.join(task_dir, 'screenshot{}.png'.format(it))
                driver_task.save_screenshot(img_path)

                # encode image
                b64_img = encode_image(img_path)
                
                """=======================================Error Grounding Agent========================================================"""
                if it > 1 and activate_EGA:
                    # 將EGA的prompt和screenshot封裝進msg
                    # EGA_messages = [{'role': 'system', 'parts': ERROR_GROUNDING_AGENT_PROMPT}]
                    EGA_messages = []
                    EGA_explanation = ""
                    # EGA_img = encode_image(img_path)
                    EGA_user_message = {
                        'role': 'user',
                        'parts': [
                            {'text': 'Thought:'+bot_thought+'\nAction:'+chosen_action+'\nScreenshot:'},
                            {'inline_data': {"mime_type": "image/png", "data": "{}".format(b64_img)}}
                        ]
                    }
                    EGA_message = EGA_user_message
                    EGA_messages.append(EGA_user_message)
                    prompt_tokens, completion_tokens, gemini_call_error, google_response = call_gemini_api(args, client, EGA_messages, ERROR_GROUNDING_AGENT_PROMPT)
                    if gemini_call_error:
                        break
                    else:
                        accumulate_prompt_token += prompt_tokens
                        accumulate_completion_token += completion_tokens
                        logging.info(f'Accumulate Prompt Tokens: {accumulate_prompt_token}; Accumulate Completion Tokens: {accumulate_completion_token}')
                        logging.info('API call complete...')
                    EGA_res = google_response.candidates[0].content.parts[0].text
                    if re.split(pattern, EGA_res)[1].strip() == 'Yes':
                        error_exist = True
                    elif re.split(pattern, EGA_res)[1].strip() == 'No':
                        error_exist = False
                    else:
                        error_exist = False
                        print("error_exist got unexpected result:", EGA_res)
                    if error_exist == True:
                        EGA_explanation = re.split(pattern, EGA_res)[2].strip()
                
                """==================================================================================================================="""
                    
                # accessibility tree
                if (not args.text_only) and args.save_accessibility_tree:
                    accessibility_tree_path = os.path.join(task_dir, 'accessibility_tree{}'.format(it))
                    get_webarena_accessibility_tree(driver_task, accessibility_tree_path)

                # format msg
                if not args.text_only:
                    curr_msg = format_msg(it, init_msg, pdf_obs, warn_obs, b64_img, web_eles_text, SYSTEM_PREVIOUS_STEP + current_history)
                    if error_exist == True:
                        curr_msg['parts'][0]['text'] += ("\nAdditional Information: Looks like your previous thought has some problem in operation. Here is the message from Error Grounding Agent\n"+EGA_explanation)
                else:
                    curr_msg = format_msg_text_only(it, init_msg, pdf_obs, warn_obs, ac_tree, SYSTEM_PREVIOUS_STEP + current_history)
                    if error_exist == True:
                        curr_msg['parts']+=("\nAdditional Information: Looks like your previous thought has some problem in operation. Here is the message from Error Grounding Agent\n"+EGA_explanation)
                message = curr_msg
                messages.append(curr_msg)
            else:
                curr_msg = {
                    'role': 'user',
                    'parts': [
                        {'text': fail_obs}
                    ]
                }
                message = curr_msg
                messages.append(curr_msg)
                

            # Clip messages, too many attached images may cause confusion
            if not args.text_only:
                messages = clip_message_and_obs(messages, args.max_attached_imgs)
                # EGA_messages = clip_message_and_obs(EGA_messages, args.max_attached_imgs)
            else:
                messages = clip_message_and_obs_text_only(messages, args.max_attached_imgs)
                # EGA_messages = clip_message_and_obs_text_only(EGA_messages, args.max_attached_imgs)

            # Call GPT-4v API
            # prompt_tokens, completion_tokens, gpt_call_error, openai_response = call_gpt4v_api(args, client, messages)
            if not args.text_only:
                prompt_tokens, completion_tokens, gemini_call_error, google_response = call_gemini_api(args, client, messages, SYSTEM_PROMPT)
            else:
                prompt_tokens, completion_tokens, gemini_call_error, google_response = call_gemini_api(args, client, messages, SYSTEM_PROMPT_TEXT_ONLY)

            if gemini_call_error:
                break
            else:
                accumulate_prompt_token += prompt_tokens
                accumulate_completion_token += completion_tokens
                logging.info(f'Accumulate Prompt Tokens: {accumulate_prompt_token}; Accumulate Completion Tokens: {accumulate_completion_token}')
                logging.info('API call complete...')
            gemini_res = google_response.candidates[0].content.parts[0].text
            messages.append({
                'role': 'model',
                'parts': [
                    {'text': gemini_res}
                ]
            })


            # remove the rects on the website
            if (not args.text_only) and rects:
                logging.info(f"Num of interactive elements: {len(rects)}")
                for rect_ele in rects:
                    driver_task.execute_script("arguments[0].remove()", rect_ele)
                rects = []
                # driver_task.save_screenshot(os.path.join(task_dir, 'screenshot{}_no_box.png'.format(it)))


            # extract action info
            try:
                assert 'Thought:' in gemini_res and 'Action:' in gemini_res
            except AssertionError as e:
                logging.error(e)
                fail_obs = "Format ERROR: Both 'Thought' and 'Action' should be included in your reply."
                continue


            """==========================================記錄此次迭代的錯誤信息和推理路徑==========================================="""
            bot_thought = re.split(pattern, gemini_res)[1].strip()
            chosen_action = re.split(pattern, gemini_res)[2].strip()
            
            trajectory_info = f"Thought: {bot_thought}\nAction: {chosen_action}\n"
            error_info = f"Error: {error_exist}\nExplanation: {EGA_explanation}\n"
            
            if args.trajectory:
                current_history += trajectory_info
                if activate_EGA:
                    current_history += error_info
                    
            print(f"Step {it}:\n{error_info}\n{trajectory_info}\n----")
            """==================================================================================================================="""
            # print(chosen_action)
            action_key, info = extract_information(chosen_action)

            fail_obs = ""
            pdf_obs = ""
            warn_obs = ""
            # execute action
            try:
                window_handle_task = driver_task.current_window_handle
                driver_task.switch_to.window(window_handle_task)

                if action_key == 'click':
                    if not args.text_only:
                        click_ele_number = int(info[0])
                        web_ele = web_eles[click_ele_number]
                    else:
                        click_ele_number = info[0]
                        element_box = obs_info[click_ele_number]['union_bound']
                        element_box_center = (element_box[0] + element_box[2] // 2,
                                              element_box[1] + element_box[3] // 2)
                        web_ele = driver_task.execute_script("return document.elementFromPoint(arguments[0], arguments[1]);", element_box_center[0], element_box_center[1])

                    ele_tag_name = web_ele.tag_name.lower()
                    ele_type = web_ele.get_attribute("type")

                    exec_action_click(info, web_ele, driver_task)

                    # deal with PDF file
                    current_files = sorted(os.listdir(args.download_dir))
                    if current_files != download_files:
                        # wait for download finish
                        time.sleep(10)
                        current_files = sorted(os.listdir(args.download_dir))

                        current_download_file = [pdf_file for pdf_file in current_files if pdf_file not in download_files and pdf_file.endswith('.pdf')]
                        if current_download_file:
                            print("processing PDF file...")
                            pdf_file = current_download_file[0]
                            
                            # 添加到向量數據庫
                            try:
                                rag_system.add_pdf(os.path.join(args.download_dir, pdf_file))
                                logging.info(f"Successfully added PDF to vector database: {pdf_file}")
                                
                                # 使用 RAG 系統生成摘要
                                # pdf_obs = get_pdf_retrieval_ans_from_rag(
                                #     args=args,
                                #     client=client,
                                #     task=task['ques'],
                                #     rag_system=rag_system
                                # )

                            except Exception as e:
                                logging.error(f"Error adding PDF to RAG system: {str(e)}")
                                pdf_obs = f"處理 PDF 文件時發生錯誤：{str(e)}"
                            
                            # pdf_obs = get_pdf_retrieval_ans_from_assistant(client, os.path.join(args.download_dir, pdf_file), task['ques'])
                            shutil.copy(os.path.join(args.download_dir, pdf_file), task_dir)
                            # pdf_obs = "You downloaded a PDF file, I ask the Assistant API to answer the task based on the PDF file and get the following response: " + pdf_obs
                            
                            
                        download_files = current_files

                    if ele_tag_name == 'button' and ele_type == 'submit':
                        time.sleep(10)

                elif action_key == 'wait':
                    time.sleep(5)

                elif action_key == 'type':
                    if not args.text_only:
                        type_ele_number = int(info['number'])
                        web_ele = web_eles[type_ele_number]
                    else:
                        type_ele_number = info['number']
                        element_box = obs_info[type_ele_number]['union_bound']
                        element_box_center = (element_box[0] + element_box[2] // 2,
                                              element_box[1] + element_box[3] // 2)
                        web_ele = driver_task.execute_script("return document.elementFromPoint(arguments[0], arguments[1]);", element_box_center[0], element_box_center[1])

                    warn_obs = exec_action_type(info, web_ele, driver_task)
                    if 'wolfram' in task['web']:
                        time.sleep(5)

                elif action_key == "select":
                    if not args.text_only:
                        select_ele_number = int(info['number'])
                        web_ele = web_eles[select_ele_number]
                    else:
                        type_ele_number = info['number']
                        element_box = obs_info[type_ele_number]['union_bound']
                        element_box_center = (element_box[0] + element_box[2] // 2,
                                              element_box[1] + element_box[3] // 2)
                        web_ele = driver_task.execute_script("return document.elementFromPoint(arguments[0], arguments[1]);", element_box_center[0], element_box_center[1])

                    warn_obs = exec_action_select(info, web_ele, driver_task)

                elif action_key == 'scroll':
                    if not args.text_only:
                        exec_action_scroll(info, web_eles, driver_task, args, None)
                    else:
                        exec_action_scroll(info, None, driver_task, args, obs_info)

                elif action_key == 'goback':
                    driver_task.back()
                    time.sleep(2)

                elif action_key == 'google':
                    driver_task.get('https://www.google.com/')
                    time.sleep(2)
                    
                elif action_key == 'generatetext':
                    logging.info('call generatetext Agent')
                    pdf_obs = exec_action_generatetext(args, client, info, rag_system)
                    
                    # 將摘要保存為 markdown 文件
                    try:
                        # 生成文件名（使用時間戳避免重複）
                        timestamp = time.strftime("%Y%m%d_%H_%M_%S", time.localtime())
                        md_filename = f"summary_{timestamp}.md"
                        md_path = os.path.join(task_dir, md_filename)
                        
                        # 寫入文件
                        with open(md_path, 'w', encoding='utf-8') as f:
                            f.write("# 文獻摘要\n\n")
                            f.write(f"## 任務描述\n{info['parts']}\n\n")
                            f.write("## 生成摘要\n")
                            f.write(pdf_obs)
                            
                        logging.info(f"摘要已保存至：{md_path}")
                        
                    except Exception as e:
                        logging.error(f"保存摘要文件時發生錯誤：{str(e)}")
                    
                    pdf_obs = "You use the RAG, I ask the Generatetext Agent to answer the task based on the PDF file and get the following response: " + pdf_obs
                    logging.info('generatetext Agent finish')
                    break

                elif action_key == 'answer':
                    logging.info(info['parts'])
                    logging.info('finish!!')
                    break

                else:
                    raise NotImplementedError
                fail_obs = ""
            except Exception as e:
                logging.error('driver error info:')
                logging.error(e)
                if 'element click intercepted' not in str(e):
                    fail_obs = "The action you have chosen cannot be exected. Please double-check if you have selected the wrong Numerical Label or Action or Action format. Then provide the revised Thought and Action."
                else:
                    fail_obs = ""
                time.sleep(2)

        print_message(messages, task_dir)
        driver_task.quit()
        logging.info(f'Total cost: {accumulate_prompt_token / 1000 * 0.01 + accumulate_completion_token / 1000 * 0.03}')


if __name__ == '__main__':
    main()
    print('End of process')
